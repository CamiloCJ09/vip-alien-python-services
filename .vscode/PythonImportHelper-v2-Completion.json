[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "Analytics.clustering.kmeans",
        "description": "Analytics.clustering.kmeans",
        "isExtraImport": true,
        "detail": "Analytics.clustering.kmeans",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "Analytics.clustering.kmeans",
        "description": "Analytics.clustering.kmeans",
        "isExtraImport": true,
        "detail": "Analytics.clustering.kmeans",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "Analytics.clustering.kmeans",
        "description": "Analytics.clustering.kmeans",
        "isExtraImport": true,
        "detail": "Analytics.clustering.kmeans",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "style",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "style",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pca",
        "importPath": "Analytics.PCA",
        "description": "Analytics.PCA",
        "isExtraImport": true,
        "detail": "Analytics.PCA",
        "documentation": {}
    },
    {
        "label": "buddy",
        "importPath": "Analytics.clustering.Pruebas.datasets.routes",
        "description": "Analytics.clustering.Pruebas.datasets.routes",
        "isExtraImport": true,
        "detail": "Analytics.clustering.Pruebas.datasets.routes",
        "documentation": {}
    },
    {
        "label": "super",
        "importPath": "Analytics.clustering.Pruebas.datasets.routes",
        "description": "Analytics.clustering.Pruebas.datasets.routes",
        "isExtraImport": true,
        "detail": "Analytics.clustering.Pruebas.datasets.routes",
        "documentation": {}
    },
    {
        "label": "KPrototypes",
        "importPath": "Analytics.clustering.kprototypes.KPrototypes",
        "description": "Analytics.clustering.kprototypes.KPrototypes",
        "isExtraImport": true,
        "detail": "Analytics.clustering.kprototypes.KPrototypes",
        "documentation": {}
    },
    {
        "label": "forecasts",
        "importPath": "Analytics.Forecasts",
        "description": "Analytics.Forecasts",
        "isExtraImport": true,
        "detail": "Analytics.Forecasts",
        "documentation": {}
    },
    {
        "label": "KPrototypes",
        "importPath": "Analytics.clustering.kprototypes",
        "description": "Analytics.clustering.kprototypes",
        "isExtraImport": true,
        "detail": "Analytics.clustering.kprototypes",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "kind": 6,
        "importPath": "Analytics.clustering.kmeans.KMeans",
        "description": "Analytics.clustering.kmeans.KMeans",
        "peekOfCode": "class KMeans():\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans \n    param: k - número de clusters\n    param: max_iter - número máximo de iteraciones\n    pre: k esté definida\n    post: se crea un nuevo objeto de tipo Kmeans\n  \"\"\"\n  def __init__(self, k, max_iter=300, random_state=19):\n    self.k = k ",
        "detail": "Analytics.clustering.kmeans.KMeans",
        "documentation": {}
    },
    {
        "label": "KPrototypes",
        "kind": 6,
        "importPath": "Analytics.clustering.kprototypes.KPrototypes",
        "description": "Analytics.clustering.kprototypes.KPrototypes",
        "peekOfCode": "class KPrototypes(KMeans):\n  \"\"\"\n    Inicializa un nuevo objeto de tipo KMeans \n    param: k - número de clusters\n    param: max_iter - número máximo de iteraciones\n    pre: k esté definida\n    post: se crea un nuevo objeto de tipo Kmeans\n  \"\"\"\n  def __init__(self, k, cat, plot_var, max_iter=300):\n    self.k = k ",
        "detail": "Analytics.clustering.kprototypes.KPrototypes",
        "documentation": {}
    },
    {
        "label": "folder",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.datasets.routes",
        "description": "Analytics.clustering.Pruebas.datasets.routes",
        "peekOfCode": "folder = os.path.dirname(os.path.abspath(__file__))\nbuddy = os.path.join(folder, 'buddymove_holidayiq.csv')\nsuper = os.path.join(folder,'super.csv')",
        "detail": "Analytics.clustering.Pruebas.datasets.routes",
        "documentation": {}
    },
    {
        "label": "buddy",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.datasets.routes",
        "description": "Analytics.clustering.Pruebas.datasets.routes",
        "peekOfCode": "buddy = os.path.join(folder, 'buddymove_holidayiq.csv')\nsuper = os.path.join(folder,'super.csv')",
        "detail": "Analytics.clustering.Pruebas.datasets.routes",
        "documentation": {}
    },
    {
        "label": "super",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.datasets.routes",
        "description": "Analytics.clustering.Pruebas.datasets.routes",
        "peekOfCode": "super = os.path.join(folder,'super.csv')",
        "detail": "Analytics.clustering.Pruebas.datasets.routes",
        "documentation": {}
    },
    {
        "label": "data1",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "data1 = pd.read_csv(buddy, header = None)\n#plt.scatter(data1[0].values, data1[1].values)\n'''print(data1.tail())'''\nnormalized_df = ((data1-data1.mean())/data1.std()).to_numpy()\n'''\nprint('Uno\\n')\nprint(normalized_df)\n'''\n#Normalizacion de datos, para que se conserve el tipo de dato\ndf_scaled = StandardScaler()",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "normalized_df",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "normalized_df = ((data1-data1.mean())/data1.std()).to_numpy()\n'''\nprint('Uno\\n')\nprint(normalized_df)\n'''\n#Normalizacion de datos, para que se conserve el tipo de dato\ndf_scaled = StandardScaler()\ndf_scaled = pd.DataFrame(df_scaled.fit_transform(data1),columns  = data1.columns )\n'''print(df_scaled.tail())'''\n\"\"\"Acontinuecion se realizara el proceso para escoger la cantidad adecuada de clusters\"\"\"",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "df_scaled",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "df_scaled = StandardScaler()\ndf_scaled = pd.DataFrame(df_scaled.fit_transform(data1),columns  = data1.columns )\n'''print(df_scaled.tail())'''\n\"\"\"Acontinuecion se realizara el proceso para escoger la cantidad adecuada de clusters\"\"\"\n#Se crea un arreglo donde se guardaran la distorcion con la cantidad de clusters\n#En terminos matematicos, se guardara la suma de las distancias al cuadrados de todos los puntos a su centro asignado\ndistortions = []\nK = range(1,6)\nred = pca(2)\nfor k in K:",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "df_scaled",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "df_scaled = pd.DataFrame(df_scaled.fit_transform(data1),columns  = data1.columns )\n'''print(df_scaled.tail())'''\n\"\"\"Acontinuecion se realizara el proceso para escoger la cantidad adecuada de clusters\"\"\"\n#Se crea un arreglo donde se guardaran la distorcion con la cantidad de clusters\n#En terminos matematicos, se guardara la suma de las distancias al cuadrados de todos los puntos a su centro asignado\ndistortions = []\nK = range(1,6)\nred = pca(2)\nfor k in K:\n    clf = KMeans(k=k)",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "distortions",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "distortions = []\nK = range(1,6)\nred = pca(2)\nfor k in K:\n    clf = KMeans(k=k)\n    df_compress = red.fit(df_scaled)\n    clf.fit(df_compress)\n    for i in range(50):\n        clf.step(clf.data)\n    distortions.append(clf.distortion)",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "K",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "K = range(1,6)\nred = pca(2)\nfor k in K:\n    clf = KMeans(k=k)\n    df_compress = red.fit(df_scaled)\n    clf.fit(df_compress)\n    for i in range(50):\n        clf.step(clf.data)\n    distortions.append(clf.distortion)\nprint(len(distortions))",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "red",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "red = pca(2)\nfor k in K:\n    clf = KMeans(k=k)\n    df_compress = red.fit(df_scaled)\n    clf.fit(df_compress)\n    for i in range(50):\n        clf.step(clf.data)\n    distortions.append(clf.distortion)\nprint(len(distortions))\nplt.figure(figsize=(12, 6))",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "colors = 10 * [\"g\", \"r\", \"c\", \"b\", \"k\", \"y\", \"m\"]\nkm = KMeans(k=3)\ncomp = pca(2)\ndat = comp.fit(df_scaled)\nkm.fit(dat)\nfor i in range(200):\n    km.step(km.data)\nfor classification in km.clasified_data:\n    color = colors[classification]\n    for featureset in km.clasified_data[classification]:",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "km",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "km = KMeans(k=3)\ncomp = pca(2)\ndat = comp.fit(df_scaled)\nkm.fit(dat)\nfor i in range(200):\n    km.step(km.data)\nfor classification in km.clasified_data:\n    color = colors[classification]\n    for featureset in km.clasified_data[classification]:\n        plt.scatter(featureset[0], featureset[1], color=color, s=80, linewidths=2)",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "comp",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "comp = pca(2)\ndat = comp.fit(df_scaled)\nkm.fit(dat)\nfor i in range(200):\n    km.step(km.data)\nfor classification in km.clasified_data:\n    color = colors[classification]\n    for featureset in km.clasified_data[classification]:\n        plt.scatter(featureset[0], featureset[1], color=color, s=80, linewidths=2)\n# print(clf.centroids)",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "dat",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kmeans_test",
        "description": "Analytics.clustering.Pruebas.kmeans_test",
        "peekOfCode": "dat = comp.fit(df_scaled)\nkm.fit(dat)\nfor i in range(200):\n    km.step(km.data)\nfor classification in km.clasified_data:\n    color = colors[classification]\n    for featureset in km.clasified_data[classification]:\n        plt.scatter(featureset[0], featureset[1], color=color, s=80, linewidths=2)\n# print(clf.centroids)\nfor centroid in km.real_crentroids:",
        "detail": "Analytics.clustering.Pruebas.kmeans_test",
        "documentation": {}
    },
    {
        "label": "data1",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kprototypes_test",
        "description": "Analytics.clustering.Pruebas.kprototypes_test",
        "peekOfCode": "data1 = pd.read_csv(super, sep=',')\nprint(data1)\nnormalized_df = ((data1-data1.mean())/data1.std()).to_numpy()\nclf = KPrototypes(cat = [0, 1], plot_var= [3,4], k = 6)\nclf.fit(normalized_df)\nfor centroid in clf.centroids:\n    plt.scatter(clf.centroids[centroid][0], clf.centroids[centroid][1],\n                marker=\"x\", color=\"k\", s=150, linewidths=5)\ncolors = 10*[\"g\",\"r\",\"c\",\"b\",\"k\"]\nfor classification in clf.clasified_data:",
        "detail": "Analytics.clustering.Pruebas.kprototypes_test",
        "documentation": {}
    },
    {
        "label": "normalized_df",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kprototypes_test",
        "description": "Analytics.clustering.Pruebas.kprototypes_test",
        "peekOfCode": "normalized_df = ((data1-data1.mean())/data1.std()).to_numpy()\nclf = KPrototypes(cat = [0, 1], plot_var= [3,4], k = 6)\nclf.fit(normalized_df)\nfor centroid in clf.centroids:\n    plt.scatter(clf.centroids[centroid][0], clf.centroids[centroid][1],\n                marker=\"x\", color=\"k\", s=150, linewidths=5)\ncolors = 10*[\"g\",\"r\",\"c\",\"b\",\"k\"]\nfor classification in clf.clasified_data:\n    color = colors[classification]\n    for featureset in clf.clasified_data[classification]:",
        "detail": "Analytics.clustering.Pruebas.kprototypes_test",
        "documentation": {}
    },
    {
        "label": "clf",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kprototypes_test",
        "description": "Analytics.clustering.Pruebas.kprototypes_test",
        "peekOfCode": "clf = KPrototypes(cat = [0, 1], plot_var= [3,4], k = 6)\nclf.fit(normalized_df)\nfor centroid in clf.centroids:\n    plt.scatter(clf.centroids[centroid][0], clf.centroids[centroid][1],\n                marker=\"x\", color=\"k\", s=150, linewidths=5)\ncolors = 10*[\"g\",\"r\",\"c\",\"b\",\"k\"]\nfor classification in clf.clasified_data:\n    color = colors[classification]\n    for featureset in clf.clasified_data[classification]:\n        plt.scatter(featureset[clf.plot_var[0]], featureset[clf.plot_var[1]], color=color, s=80, linewidths=2)",
        "detail": "Analytics.clustering.Pruebas.kprototypes_test",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "Analytics.clustering.Pruebas.kprototypes_test",
        "description": "Analytics.clustering.Pruebas.kprototypes_test",
        "peekOfCode": "colors = 10*[\"g\",\"r\",\"c\",\"b\",\"k\"]\nfor classification in clf.clasified_data:\n    color = colors[classification]\n    for featureset in clf.clasified_data[classification]:\n        plt.scatter(featureset[clf.plot_var[0]], featureset[clf.plot_var[1]], color=color, s=80, linewidths=2)\nplt.show()",
        "detail": "Analytics.clustering.Pruebas.kprototypes_test",
        "documentation": {}
    },
    {
        "label": "HelloWorld",
        "kind": 2,
        "importPath": "Analytics.Forecasts.forecasts",
        "description": "Analytics.Forecasts.forecasts",
        "peekOfCode": "def HelloWorld():\n    return \"Hello, World!\"",
        "detail": "Analytics.Forecasts.forecasts",
        "documentation": {}
    },
    {
        "label": "pca",
        "kind": 6,
        "importPath": "Analytics.PCA.pca",
        "description": "Analytics.PCA.pca",
        "peekOfCode": "class pca():\n    def __init__(self, n):\n        self.n = n\n    def fit(self, data):\n        #Calculo de la matrix de convarinza\n        cov_mat = np.cov(data.T)\n        '''print('NumPy covariance matrix: \\n%s' %cov_mat)'''\n        #Calculo de los eigenvector y eigenvalues\n        eigen_vals, eigen_vecs = np.linalg.eig(cov_mat)\n        '''",
        "detail": "Analytics.PCA.pca",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "run",
        "description": "run",
        "peekOfCode": "app = Flask(__name__)\napp.add_url_rule('/', view_func=forecasts.HelloWorld)\n\"\"\"\napp.add_url_rule('/', view_func=KMeans.)\napp.add_url_rule('/', view_func=KPrototypes.)\n\"\"\"",
        "detail": "run",
        "documentation": {}
    }
]